// Generated by CoffeeScript 1.10.0
(function() {
  var ConsoleLogger, GenericEmitter, LOGLEVEL, Logger, MessageEmitter, Spy, logger1, logger2, logger3;

  MessageEmitter = Observatory.MessageEmitter, GenericEmitter = Observatory.GenericEmitter, Logger = Observatory.Logger, ConsoleLogger = Observatory.ConsoleLogger, LOGLEVEL = Observatory.LOGLEVEL;

  Spy = {
    calledMethod: ['', '', '']
  };

  logger1 = {
    name: "logger1",
    addMessage: function(msg) {
      return Spy.calledMethod[0] = msg;
    }
  };

  logger2 = {
    name: "logger2",
    addMessage: function(msg) {
      return Spy.calledMethod[1] = msg;
    }
  };

  logger3 = {
    name: "logger3",
    addMessage: function(msg) {
      return Spy.calledMethod[2] = msg;
    }
  };

  describe('Observatory - centralized code and functions', function() {
    it('should be created with empty loggers buffer and provide correct log levels arrays', function() {
      Observatory._loggers.should.be.empty;
      return Observatory.LOGLEVEL.should.be.eql({
        SILENT: -1,
        FATAL: 0,
        ERROR: 1,
        WARNING: 2,
        INFO: 3,
        VERBOSE: 4,
        DEBUG: 5,
        MAX: 6,
        NAMES: ["FATAL", "ERROR", "WARNING", "INFO", "VERBOSE", "DEBUG", "MAX"]
      });
    });
    describe('subscribeLogger()', function() {
      return it('should allow logger subscription', function() {
        Observatory.subscribeLogger(logger1);
        Observatory.subscribeLogger(logger2);
        Observatory._loggers.length.should.equal(2);
        Observatory._loggers[0].should.equal(logger1);
        return Observatory._loggers[1].should.equal(logger2);
      });
    });
    describe('unsubscribeLogger()', function() {
      return it('should unsubscribe loggers', function() {
        Observatory.unsubscribeLogger(logger1);
        Observatory._loggers.length.should.equal(1);
        Observatory._loggers[0].should.equal(logger2);
        Observatory.unsubscribeLogger(logger2);
        return Observatory._loggers.should.be.empty;
      });
    });
    describe('Formatters - functions that take arbitrary json and format it into message to log', function() {
      return describe('basicFormatter', function() {
        return it('should format object with severity, client / server, date and message', function() {
          var msgr, obj;
          obj = {
            a: 'a',
            b: 1
          };
          msgr = Observatory.formatters.basicFormatter({
            severity: LOGLEVEL.INFO,
            message: 'test message',
            module: 'module',
            obj: obj
          });
          msgr.timestamp.should.exist;
          msgr.severity.should.equal(LOGLEVEL.INFO);
          msgr.textMessage.should.equal('test message');
          msgr.module.should.equal('module');
          msgr.isServer.should.equal(Observatory.isServer());
          return msgr.object.should.equal(obj);
        });
      });
    });
    describe('MessageEmitter - base class for anything that can produce a message to log', function() {
      var me;
      me = new MessageEmitter("newEmitter");
      logger1 = {
        name: "logger1",
        addMessage: function(msg) {
          return Spy.calledMethod[0] = msg;
        }
      };
      logger2 = {
        name: "logger2",
        addMessage: function(msg) {
          return Spy.calledMethod[1] = msg;
        }
      };
      it('should be created with empty loggers buffer and name set correctly', function() {
        me._loggers.should.be.empty;
        return me.name.should.equal("newEmitter");
      });
      it('should allow logger subscription', function() {
        me.subscribeLogger(logger1);
        me.subscribeLogger(logger2);
        me._loggers.length.should.equal(2);
        me._loggers[0].should.equal(logger1);
        return me._loggers[1].should.equal(logger2);
      });
      it('should send messages to each subscribed logger, both local and global', function() {
        var j, len, m, msg, ref, results;
        Observatory.subscribeLogger(logger3);
        msg = "test message";
        me.emitMessage(msg);
        ref = Spy.calledMethod;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          m = ref[j];
          results.push(m.should.equal(msg));
        }
        return results;
      });
      return it('should unsubscribe loggers', function() {
        me.unsubscribeLogger(logger1);
        me._loggers.length.should.equal(1);
        me._loggers[0].should.equal(logger2);
        me.unsubscribeLogger(logger2);
        return me._loggers.should.be.empty;
      });
    });
    describe('GenericEmitter - typical logging functionality provider to be used in apps', function() {
      var gem;
      gem = new GenericEmitter("Gem", LOGLEVEL.MAX);
      it('should be created with correct name, should set maximum severity and default formatter', function() {
        gem.name.should.equal("Gem");
        gem.maxSeverity.should.equal(LOGLEVEL.MAX);
        return gem.formatter.should.equal(Observatory.formatters.basicFormatter);
      });
      it('should respond to all severity logging methods and emit them at the correct level', function() {
        var i, j, len, m, msgr, obj, ref, results;
        obj = {
          a: 'a',
          b: 1
        };
        ref = ['fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'insaneVerbose'];
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          m = ref[i];
          gem.should.respondTo(m);
          msgr = gem[m]('test message', obj);
          msgr.timestamp.should.exist;
          msgr.severity.should.equal(i);
          msgr.textMessage.should.equal('test message');
          msgr.module.should.equal('Gem');
          msgr.isServer.should.equal(Observatory.isServer());
          msgr.object.should.equal(obj);
          results.push(msgr.should.be.equal(Spy.calledMethod[2]));
        }
        return results;
      });
      return describe('_emitWithSeverity - main method for forming messages', function() {
        return it('should shift arguments around correctly', function() {
          var m, obj;
          obj = {
            a: 'a',
            b: 1
          };
          m = gem.info(obj, 'module');
          m.object.should.equal(obj);
          m.module.should.equal('module');
          m.textMessage.should.equal(JSON.stringify(obj));
          m = gem.info('test message');
          should.not.exist(m.object);
          m.module.should.equal('Gem');
          m.textMessage.should.equal('test message');
          m = gem.info('test message', 'module');
          should.not.exist(m.object);
          m.module.should.equal('module');
          return m.textMessage.should.equal('test message');
        });
      });
    });
    describe('Logger - base class for all loggers that listen to messages and output them somewhere', function() {
      var l;
      l = new Logger('logger');
      it('should be created with defaults', function() {
        l.name.should.equal('logger');
        l.useBuffer.should.be["false"];
        l.interval.should.equal(3000);
        return l.formatter.should.equal(Observatory.viewFormatters.basicConsole);
      });
      describe('addMessage(message)', function() {
        it('should not accept malformed messages', function() {
          return (function() {
            return l.addMessage(null);
          }).should["throw"](Error);
        });
        return it('should accept well-formed messages but throw error when logging', function() {
          var goodm;
          goodm = {
            timestamp: new Date,
            severity: 0,
            textMessage: 'error',
            isServer: true
          };
          l.messageAcceptable(goodm).should.be["true"];
          return (function() {
            return l.addMessage(goodm);
          }).should["throw"](Error);
        });
      });
      return describe('addMessage(message) with buffer', function() {
        var goodm, l1;
        l1 = new Logger('logger1', true);
        goodm = {
          timestamp: new Date,
          severity: 0,
          textMessage: 'error',
          isServer: true
        };
        it('should add well-formed message to the buffer', function() {
          l1.addMessage(goodm);
          return l1.messageBuffer.length.should.equal(1);
        });
        it('should not add malformed message to the buffer', function() {
          (function() {
            return l1.addMessage(null);
          }).should["throw"](Error);
          return l1.messageBuffer.length.should.equal(1);
        });
        return describe('processBuffer()', function() {
          return it('should throw exception as log() must be overriden', function() {
            return (function() {
              return l1.processBuffer();
            }).should["throw"](Error);
          });
        });
      });
    });
    describe('ConsoleLogger - basic logger to the console', function() {
      var l;
      l = new ConsoleLogger;
      return describe('addMessage(message)', function() {
        it('should not accept malformed messages', function() {
          return (function() {
            return l.addMessage(null);
          }).should["throw"](Error);
        });
        return it('should accept well-formed messages and print it out', function() {
          var cc, dt, goodm, tmp;
          dt = new Date(2013, 5, 5);
          goodm = {
            timestamp: dt,
            severity: 0,
            textMessage: 'error',
            isServer: true,
            object: {
              a: 'a',
              b: 1
            }
          };
          l.messageAcceptable(goodm).should.be["true"];
          cc = console.log;
          tmp = '';
          console.log = function(m) {
            return tmp = m;
          };
          (function() {
            return l.addMessage(goodm);
          }).should.not["throw"](Error);
          tmp.should.equal('[4/6/2013][22:0:0.0][SERVER][][FATAL] error | {"a":"a","b":1}');
          return console.log = cc;
        });
      });
    });
    return describe('============ Some Integration Tests =============', function() {
      return describe('Observatory.initialize()', function() {
        return it('should setup basic logging infrastructure: 1 console logger, default emitter, settings', function() {
          var dl;
          Observatory.initialize({
            logLevel: 'DEBUG'
          });
          Observatory.settings.maxSeverity.should.equal(LOGLEVEL.DEBUG);
          Observatory.getLoggers().length.should.equal(1);
          dl = Observatory.getDefaultLogger();
          dl.should.be.an.instanceOf(GenericEmitter);
          return describe('Now testing how messages from emitter reach the logger', function() {
            return it('should print stuff out - look at the screen!', function() {

              /*
              dl.info 'Message is this'
              b = a: 'a', b: 1, d: new Date
              dl.verbose 'too much words', b
              dl.debug 'Debug message', 'my module'
              try
                #Observatory.notExistingMethod()
                throw new Error 'Test Error'
              catch e
                dl.trace e, 'tests'
               */
            });
          });
        });
      });
    });
  });

}).call(this);
