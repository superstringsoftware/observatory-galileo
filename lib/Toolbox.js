// Generated by CoffeeScript 1.10.0

/*

   * Commented out for Meteor usage

if require?
  Observatory = (require './Observatory.coffee').Observatory
  {MessageEmitter, GenericEmitter, Logger, ConsoleLogger, LOGLEVEL} = Observatory
 */

(function() {
  var Observatory, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Observatory = (ref = this.Observatory) != null ? ref : {};

  Observatory.Toolbox = (function(superClass) {
    extend(Toolbox, superClass);

    function Toolbox() {
      this.profileAsync = bind(this.profileAsync, this);
      this.profile = bind(this.profile, this);
      return Toolbox.__super__.constructor.apply(this, arguments);
    }

    Toolbox.prototype.dumbProfile = function(message, time, object, module, severity, buffer) {
      if (module == null) {
        module = 'profiler';
      }
      if (severity == null) {
        severity = 'VERBOSE';
      }
      if (buffer == null) {
        buffer = false;
      }
      object = object != null ? object : {};
      object.timeElapsed = time;
      return this._emitWithSeverity(Observatory.LOGLEVEL[severity], message, object, module, 'profile', buffer);
    };

    Toolbox.prototype.forceDumbProfile = function(message, time, object, module, severity, buffer) {
      if (module == null) {
        module = 'profiler';
      }
      if (severity == null) {
        severity = 'VERBOSE';
      }
      if (buffer == null) {
        buffer = false;
      }
      object = object != null ? object : {};
      object.timeElapsed = time;
      return this._forceEmitWithSeverity(Observatory.LOGLEVEL[severity], message, object, module, 'profile', buffer);
    };

    Toolbox.prototype._determineProfilingLevel = function(timeElapsed) {
      var loglevel;
      loglevel = Observatory.LOGLEVEL.ERROR;
      if (timeElapsed < Observatory.settings.profiling.WARNING_THRESHOLD) {
        loglevel = Observatory.LOGLEVEL.VERBOSE;
      } else if (timeElapsed < Observatory.settings.profiling.DANGER_THRESHOLD) {
        loglevel = Observatory.LOGLEVEL.WARNING;
      }
      return loglevel;
    };

    Toolbox.prototype.profile = function(options, thisArg, func) {
      var args, loglevel, msg, object, ret, t1, t2;
      args = _.rest(_.rest(_.rest(arguments)));
      if (!Observatory.settings.profiling.isOn) {
        return func.apply(thisArg, args);
      }
      t1 = Date.now();
      ret = func.apply(thisArg, args);
      t2 = Date.now() - t1;
      loglevel = this._determineProfilingLevel(t2);
      if (loglevel > Observatory.settings.profiling.maxProfilingLevel) {
        return ret;
      }
      msg = options.method + " call finished in " + t2 + " ms | " + options.message;
      object = {
        timeElapsed: t2,
        method: options.method,
        "arguments": EJSON.stringify(args),
        stack: (new Error()).stack
      };
      this._forceEmitWithSeverity(loglevel, msg, object, 'profiler', 'profile', (options.buffer != null) === true);
      return ret;
    };

    Toolbox.prototype.profileAsync = function(options, thisArg, func) {
      var args, callback, msg, object, orig_callback, sargs;
      args = _.rest(_.rest(_.rest(arguments)));
      if (!Observatory.settings.profiling.isOn) {
        return func.apply(thisArg, args);
      }
      sargs = EJSON.stringify(args);
      orig_callback = args.pop();
      callback = (function(_this) {
        return function(err, res) {
          var loglevel, msg, object, t2;
          t2 = Date.now() - _this.__startTime;
          loglevel = _this._determineProfilingLevel(t2);
          if (loglevel < Observatory.settings.profiling.maxProfilingLevel) {
            msg = options.method + " call finished in " + t2 + " ms | " + options.message;
            object = {
              timeElapsed: t2,
              method: options.method,
              "arguments": sargs,
              stack: (new Error()).stack,
              type: "profile.end"
            };
            _this._forceEmitWithSeverity(loglevel, msg, object, 'profiler', 'profile', (options.buffer != null) === true);
          }
          if (typeof orig_callback === 'function') {
            return orig_callback(err, res);
          }
        };
      })(this);
      if (typeof orig_callback === 'function') {
        args.push(callback);
      } else {
        args.push(orig_callback);
        args.push(callback);
      }
      msg = options.method + " call started";
      object = {
        method: options.method,
        "arguments": sargs,
        stack: (new Error()).stack,
        type: "profile.start"
      };
      this._verbose(msg, object, 'profiler', 'profile', (options.buffer != null) === true);
      this.__startTime = Date.now();
      return func.apply(thisArg, args);
    };

    Toolbox.prototype.inspect = function(obj, long, print) {
      var i, it, j, k, l, len, len1, len2, ref1, ref2, ref3, ret, t, v;
      if (long == null) {
        long = false;
      }
      if (print == null) {
        print = false;
      }
      ret = {
        functions: [],
        objects: [],
        vars: [],
        varsObject: {}
      };
      for (k in obj) {
        v = obj[k];
        switch (typeof v) {
          case 'function':
            ret.functions.push({
              key: k,
              value: v.toString()
            });
            break;
          case 'object':
            ret.objects.push({
              key: k,
              value: (long ? v : "Object")
            });
            break;
          default:
            ret.vars.push({
              key: k,
              value: v
            });
            ret.varsObject[k] = v;
        }
      }
      if (print) {
        ref1 = ['functions', 'objects', 'vars'];
        for (i = 0, len = ref1.length; i < len; i++) {
          t = ref1[i];
          if (ret[t].length > 0) {
            console.log("****** PRINTING " + t + " ***********");
          }
          if (long) {
            ref2 = ret[t];
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              it = ref2[j];
              console.log(it.key + ": " + it.value);
            }
          } else {
            ref3 = ret[t];
            for (l = 0, len2 = ref3.length; l < len2; l++) {
              it = ref3[l];
              console.log(it.key);
            }
          }
        }
      }
      return ret;
    };

    return Toolbox;

  })(Observatory.GenericEmitter);

  (typeof exports !== "undefined" && exports !== null ? exports : this).Observatory = Observatory;

}).call(this);
